#! /usr/bin/env python3

import rclpy
from rclpy.action import ActionServer
from rclpy.node import Node
import socket
import struct
import threading
from builtin_interfaces.msg import Time as RosTime
from spes_msgs.msg import MoveCommand, MoveState
from spes_msgs.action import BehaviourCommand
import time


UDP_IP = '127.0.0.1'
UDP_PORT = 5000
ALLOWED_CLASSES = [41] # 41 for cup, None for all
TRACKING_DEBOUNCE_TIME = 2.0
P_LINEAR = 0.2
P_ANGULAR = 0.6
X_THRESHOLD = 0.001
Y_THRESHOLD = 0.005
TARGET_X = 0.5
TARGET_Y = 0.72
TARGET_MOVE_FORWARD = 0.3


class VisualControllerState:
    REGULATE_Y = 'REGULATE_Y'
    REGULATE_X = 'REGULATE_X'
    IDLE = 'IDLE'
    FORWARD = 'FORWARD'


class UDPStreamer:
    BUFFER_SIZE = 1024
    PACK_STRING = '>HIHHHHBqqHH'

    class Detection:
        def __init__(self):
            self.class_ = 0
            self.instance = 0
            self.center_x = 0
            self.center_y = 0
            self.height = 0
            self.width = 0
            self.precision = 0
            self.timestamp_sec = 0
            self.timestamp_nsec = 0
            self.image_width = 0
            self.image_height = 0

        def timestamp(self):
            return self.timestamp_sec + self.timestamp_nsec / 1e9

    def __init__(self, ip, port):
        self.__sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.__sock.bind(('0.0.0.0', 0))
        self.__server = (ip, port)
        self.__sock.settimeout(1.0)

        self.__running = True
        self.__threading = threading.Thread(target=self.__listener)
        self.__threading.start()

        self.__on_detection_callback = None

    def __parse_message(self, data):
        detections = []
        num_detections = struct.unpack('>H', data[:2])[0]
        pack_string_size = struct.calcsize(self.PACK_STRING)
        data = data[2:]
        for _ in range(num_detections):
            tokens = struct.unpack(self.PACK_STRING, data[:pack_string_size])
            data = data[pack_string_size:]

            detection = self.Detection()
            detection.class_ = tokens[0]
            detection.instance = tokens[1]
            detection.center_x = tokens[2]
            detection.center_y = tokens[3]
            detection.height = tokens[4]
            detection.width = tokens[5]
            detection.precision = tokens[6]
            detection.timestamp_sec = tokens[7]
            detection.timestamp_nsec = tokens[8]
            detection.image_width = tokens[9]
            detection.image_height = tokens[10]
            detections.append(detection)
        return detections

    def register_on_detection(self, callback):
        self.__on_detection_callback = callback

    def __listener(self):
        while self.__running:
            data = None
            self.__sock.sendto(b'1', self.__server)
            try:
                data, _ = self.__sock.recvfrom(self.BUFFER_SIZE)
                if data:
                    detections = self.__parse_message(data)
                    if self.__on_detection_callback:
                        self.__on_detection_callback(detections)
            except socket.timeout:
                continue

    def close(self):
        self.__running = False
        self.__threading.join()
        self.__sock.close()


def filter_detections_by_classes(detections, classes):
    filtered_detections = []
    for detection in detections:
        if detection.class_ in classes:
            filtered_detections.append(detection)
    return filtered_detections


def find_detection_with_max_conf(detections):
    max_conf = 0
    max_detection = None
    for detection in detections:
        if detection.precision > max_conf:
            max_conf = detection.precision
            max_detection = detection
    return max_detection


def find_detection_by_instance_index(detections, instance_index):
    for detection in detections:
        if detection.instance == instance_index:
            return detection
    return None


def create_ros_timestamp(detection):
    ros_time = RosTime()
    ros_time.sec = detection.timestamp_sec
    ros_time.nanosec = detection.timestamp_nsec
    return ros_time


class VisualController(Node):
    def __init__(self):
        super().__init__('visual_controller')
        self.__udp_streamer = UDPStreamer(UDP_IP, UDP_PORT)

        self.__publisher = self.create_publisher(MoveCommand, '/move/command', 1)
        self.__subscriber = self.create_subscription(
            MoveState, '/move/state', self.__on_move_state, 1
        )
        self.__udp_streamer.register_on_detection(self.__on_detection_callback)

        self.__tracking_instance = None
        # self.__state = VisualControllerState.REGULATE_X
        # self.__previous_state = VisualControllerState.REGULATE_X
        self.__move_state = MoveState()
        
        super().__init__('behaviour_command_server')
        self._action_server = ActionServer(
            self,
            BehaviourCommand,
            'behaviour_command',
            self.regulate_position)
    
    def regulate_position(self, goal_handle):
        self.get_logger().info('Executing goal...' )
        move_type = goal_handle.request.move 
        tolerance = goal_handle.request.tolerance
        self.__regulate_robot(move_type, tolerance)

        goal_handle.succeed()
        self.get_logger().info(f"Motion Type: {move_type}")
        self.get_logger().info(f"Tolerance: {tolerance}")
        result = BehaviourCommand.Result()
        return result

    def __on_move_state(self, move_state):
        self.__move_state = move_state

    def __update_tracking_instance(self, detections):
        if ALLOWED_CLASSES is not None:
            detections = filter_detections_by_classes(detections, ALLOWED_CLASSES)

        if self.__tracking_instance is None:
            self.__tracking_instance = find_detection_with_max_conf(detections)

        if (
            self.__tracking_instance is not None
            and time.time() - self.__tracking_instance.timestamp()
            > TRACKING_DEBOUNCE_TIME
        ):
            print('Switching tracking instance')
            self.__tracking_instance = find_detection_with_max_conf(detections)
        # Update the current instance
        if self.__tracking_instance is not None:
            self.__tracking_instance = find_detection_by_instance_index(detections, self.__tracking_instance.instance)

    def __on_detection_callback(self, detections):
        if len(detections) == 0:
            return

        self.__update_tracking_instance(detections)
        # self.__regulate_robot()

    def __regulate_robot(self, move_type, tolerance):
        if self.__tracking_instance is None:
            return

        error_x = TARGET_X - (
            self.__tracking_instance.center_x / self.__tracking_instance.image_width
        )
        error_y = TARGET_Y - (
            self.__tracking_instance.center_y / self.__tracking_instance.image_height
        )

        self.get_logger().info(f'Error: {error_x}, {error_y}, {self.__tracking_instance.image_width}')
        
        if move_type == 0:
            while error_y > tolerance:
                self.state_regulate_y(error_x, error_y, tolerance)
                error_y = TARGET_Y - (self.__tracking_instance.center_y / self.__tracking_instance.image_height)
        if move_type == 1:
            while error_x > tolerance:
                self.state_regulate_x(error_x, error_y, tolerance)
                error_x = TARGET_X - (self.__tracking_instance.center_x / self.__tracking_instance.image_width)
        if move_type == 2:
            self.state_forward()

        self.get_logger().info(f'ERROR: {error_x}, {error_y}, {self.__tracking_instance.image_width}')
        # if self.__state == VisualControllerState.REGULATE_Y:
        #     self.state_regulate_y(error_x, error_y)
        # elif self.__state == VisualControllerState.REGULATE_X:
        #     self.state_regulate_x(error_x, error_y)
        # elif self.__state == VisualControllerState.FORWARD:
        #     self.state_forward()

        # if self.__state != self.__previous_state:
        #     self.get_logger().info(f'State changed from {self.__previous_state} to {self.__state}')
        #     self.__previous_state = self.__state

    def state_regulate_y(self, error_x, error_y, tolerance):
        # if abs(error_y) < tolerance:
        #     return

        self.get_logger().info(f"****** ANGULAR ******{error_y}")
        move_command = MoveCommand()
        move_command.header.frame_id = 'base_link'
        move_command.header.stamp = create_ros_timestamp(self.__tracking_instance)
        move_command.rotate_towards_goal = False
        move_command.rotate_at_goal = False
        move_command.target.x = error_y * P_LINEAR
        self.__publisher.publish(move_command)

    def state_regulate_x(self, error_x, error_y, tolerance):
            # if abs(error_x) < tolerance:
            #     return
            
        self.get_logger().info("f****** LINEAR ******{error_x}")
        move_command = MoveCommand()
        move_command.header.frame_id = 'base_link'
        move_command.header.stamp = create_ros_timestamp(self.__tracking_instance)
        move_command.rotate_towards_goal = False
        move_command.translate = False
        move_command.target.theta = P_ANGULAR * error_x
        self.__publisher.publish(move_command)

    def state_forward(self):
        move_command = MoveCommand()
        move_command.header.frame_id = 'base_link'
        move_command.rotate_towards_goal = False
        move_command.rotate_at_goal = False
        move_command.target.x = TARGET_MOVE_FORWARD
        self.__publisher.publish(move_command)
        # self.__state = VisualControllerState.IDLE


def main(args=None):
    rclpy.init(args=args)
    visual_controller = VisualController()
    rclpy.spin(visual_controller)
    visual_controller.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
