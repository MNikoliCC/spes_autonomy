#! /usr/bin/env python3
import rclpy
from rclpy.node import Node
import socket
import struct
import threading

from datetime import datetime, timedelta
from rclpy.time import Time
from builtin_interfaces.msg import Time as RosTime
from enum import Enum

from spes_msgs.msg import MoveCommand



UDP_IP = "127.0.0.1"
UDP_PORT = 5005

class MoveState(Enum):
    TRANSLATE = 0,
    ROTATE = 1,
    IDLE = 2


class VisualController(Node):
    def __init__(self):
        super().__init__('visual_controller')
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  # UDP
        self.sock.bind((UDP_IP, UDP_PORT))

        self._publisher = self.create_publisher(MoveCommand, '/move/command', 1)

        self.listener_thread = threading.Thread(target=self.udp_listener)
        self.listener_thread.start()
        
        self.next_state = MoveState.ROTATE
    
    def udp_listener(self):
        while True:
            data, addr = self.sock.recvfrom(2048)
            if data:
                self.process_udp_message(data, addr)
    
    def process_udp_message(self, data, addr):

        if len(data) != 35:
            return
        unpacked_data = struct.unpack('>HIHHHHBqqHH', data)

        class_ = unpacked_data[0]
        instance = unpacked_data[1]
        center_x = unpacked_data[2]
        center_y = unpacked_data[3]
        height = unpacked_data[4]
        width = unpacked_data[5]
        precision = unpacked_data[6]
        timestamp_sec = unpacked_data[7]
        timestamp_nsec = unpacked_data[8]
        image_height = unpacked_data[9]
        image_width = unpacked_data[10]

        dt = datetime.fromtimestamp(timestamp_sec)
        dt_with_ns = dt + timedelta(microseconds=timestamp_nsec // 1000)
        formatted_time = dt_with_ns.strftime("%H:%M:%S.%f")[:-3]

        self.get_logger().info(f"class = {class_}, instance = {instance}, center_x = {center_x}, center_y = {center_y}, height = {height}, width = {width}, precision = {precision/100}, timestamp_sec = {formatted_time}, image_width = {image_width}, image_height = {image_height}")
        
        self.move_robot(center_x, center_y, instance, image_width, image_height, timestamp_sec, timestamp_nsec)

    
    def move_robot(self, center_x, center_y, instance, image_width, image_height, timestamp_sec, timestamp_nsec):
        ros_time = RosTime()
        ros_time.sec = timestamp_sec
        ros_time.nanosec = timestamp_nsec

        P_LINEAR = 0.048 / image_height * 5
        P_ANGULAR = 0.128 / image_width * 5
        img_center_x = round(image_width / 2)
        img_center_y = round(image_height / 2)
        epsilon_x = round(image_width * 0.03)
        epsilon_y = round(image_height * 0.04)

        #set angular and linear velocity
        move_command = MoveCommand()
        move_command.angular_properties.max_acceleration = 0.4
        move_command.angular_properties.max_velocity = 0.2
        move_command.linear_properties.max_acceleration = 0.25
        move_command.linear_properties.max_velocity = 0.07

        if abs(img_center_x - int(center_x)) > epsilon_x and self.next_state == MoveState.ROTATE:
            move_command.target.theta = P_ANGULAR * (img_center_x - int(center_x))
            move_command.rotate_towards_goal = False
            move_command.translate = False            
            move_command.header.frame_id = 'base_link'
            move_command.header.stamp = ros_time

            self._publisher.publish(move_command)
        else:
            self.next_state = MoveState.TRANSLATE
            
            if abs(int(center_y) - img_center_y * 1.4)  > epsilon_y:
                move_command.target.x = P_LINEAR * (img_center_y * 1.4 - int(center_y))
                move_command.rotate_towards_goal = False
                move_command.translate = True
                move_command.rotate_at_goal = False
                move_command.header.frame_id = 'base_link'
                move_command.header.stamp = ros_time

                self._publisher.publish(move_command)
            else:
                self.next_state = MoveState.ROTATE
            
        if abs(img_center_x - int(center_x)) < epsilon_x and abs(int(center_y) - img_center_y * 1.4)  < epsilon_y:
            move_command.linear_properties.max_acceleration = 0.2

            move_command.target.theta = 0.0
            move_command.target.x = 0.3
            move_command.rotate_towards_goal = True
            move_command.translate = True 
            move_command.rotate_at_goal = True
            move_command.header.frame_id = 'base_link'
            move_command.header.stamp = ros_time

            self.next_state = MoveState.ROTATE

            self._publisher.publish(move_command)
            self.get_logger().info(f"=======IS CAME========")


        

def main(args=None):
    rclpy.init(args=args)
    visual_controller = VisualController()
    rclpy.spin(visual_controller)
    visual_controller.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
